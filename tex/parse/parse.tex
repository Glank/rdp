\documentclass[11pt]{article}
\usepackage{url}
\usepackage{cite}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{graphicx}
\graphicspath{{../../umlet/}}

\begin{document}

\title{Parsing}
\author{Ernest Kirstein}
\maketitle

Parsing, in the most abstract sense, is the process of attempting to fit a string (or list of tokens) to one or more structured representations.
Typically, the set of possible structured representations, $R$, is defined by some formal grammar specification.
\cite{lewis, compiler, anatomy, formal_langs}
A parsing algorithm can be though of as a routine which reduces $R$ to only those representations which are valid for a particular string.

\newtheorem{parse}{Definition}
\begin{parse}
\[ P(s, R) = \{ \forall r \in R : valid(r,s) \} \]
\end{parse}

That explanation is a bit dense, so allow me to explain.
Let's take the following context free grammar, $G$, as an example.
\begin{align*}
S &\rightarrow a \\
S &\rightarrow b S
\end{align*}

The structured representations specified by a CFG are all rooted, ordered trees called parse trees. \cite{formal_langs}
In this case, the set of parse trees defined under this CFS all have a root node which corresponds to the symbol $S$.
All $S$ nodes have either one or two child nodes:
they can have a terminal child node corresponding to the symbol $a$;
or they can have a terminal and non terminal child node corresponding to $b$ and $S$ respectively.

The following are all examples of parse trees are in $R_G$:
\begin{align*}
&(S, \{a\}) \\
&(S, \{b, (S, \{a\})\}) \\
&(S, \{b, (S, \{b, (S, \{a\})\})\}) \\
&\ldots \text{ etc.}
\end{align*}

All the trees in $R_G$ can be generated by recursively apply the rules in $G$ to non-terminal symbols according to
their corresponding rules (more on that later). \cite{formal_langs}

So now let's try to parse the string "bba" in this grammar: $P("bba", R_G)$.
To first reduce $R_G$, we might consider only those structured representations which have less than 4 terminal nodes:
\begin{align*}
&(S, \{a\}) \\
&(S, \{b, (S, \{a\})\}) \\
&(S, \{b, (S, \{b, (S, \{a\})\})\})
\end{align*}

And to complete the parsing, we can simply scan those 3 representations and determine which ones (if any) correspond to "bba".
We see that $(S, \{b, (S, \{b, (S, \{a\})\})\})$ (let's label it, $r_v$) is the only valid representation.
So we can resolve $P("bba", R_G)$ to the set containing only $r_v$.
This is, of course, a very ad hoc algorithm.
There are much more robust approaches that will be discussed shortly.

\section*{Parsing - Divide and Conquire}

Let's look at that last algorithm a little more closely. What allowed us to conclude that $r_v$ was the only valid representation
by searching only the 3 parse trees? Well, all the representations longer than 3 aren't valid so... It seems intuitive, but let's be explicit:

\newtheorem{divconq}{Theorem}
\begin{divconq}
Let $s$ be a string and let $R$, $A$, and $B$ be sets of representations such that $R \subseteq A \cup B$ and $B \subseteq R$.
If $\forall x \in A : \lnot valid(x, s)$ then $P(s, R) = P(s, B)$. 
\end{divconq}
\begin{proof}
Let $s$ be a string and let $R$, $A$, and $B$ be sets of representations such that $R \subseteq A \cup B$ and $B \subseteq R$.
For contradiction, let us assume that $\forall x \in A : \lnot valid(x, s)$ and $P(s, R) \neq P(s, B)$.
So either there must be some $r \in R$ and $r \not\in B$ that is a valid representation of $s$ or there must be
some $b \in B$ and $b \not\in R$ that is a valid representation of $s$.
The later is impossible because $B$ is a subset of $R$. 
And if $r \in R$ and $r \not\in B$ then $r \in A$ since $R \subseteq A \cup B$ and $B \subseteq R$.
But that contradicts our assumption that $\forall x \in A : \lnot valid(x,s)$.
\qedhere
\end{proof}

\bibliography{parse}{}
\bibliographystyle{plain}
\end{document}
